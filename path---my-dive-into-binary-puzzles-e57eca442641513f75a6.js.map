{"version":3,"sources":["webpack:///path---my-dive-into-binary-puzzles-e57eca442641513f75a6.js","webpack:///./.cache/json/my-dive-into-binary-puzzles.json"],"names":["webpackJsonp","407","module","exports","data","markdownRemark","html","frontmatter","title","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,y7PAA0rOC,aAAuxBC,MAAA,kDAAAC,KAAA,uBAAuFC,aAAgBC,KAAA","file":"path---my-dive-into-binary-puzzles-e57eca442641513f75a6.js","sourcesContent":["webpackJsonp([45705315560200],{\n\n/***/ 407:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h5>This blog summarizes my dive into a series of binary bitwise modulus calculation related Codewars puzzles.</h5>\\n<p>I’ve just become a 3 kyu player on Codewars. Recently I came across a 4 kyu kata on Codewars which caught my eyes particularly and made me decide to commit my time and effort in order to dig deeper into the problem. And finally, it led me solved my first 1 kyu kata.</p>\\n<blockquote>\\n</blockquote>\\n<p>Here is the description of that 4 kyu problem:</p>\\n<blockquote>\\n<p>“ Your task is to create a regular expression capable of evaluating binary strings (strings with only 1s and 0s) and determining whether the given string represents a number divisible by 3.”</p>\\n</blockquote>\\n<p>And it came with a hint:</p>\\n<blockquote>\\n<p>“There’s a way to develop an automata (FSM) that evaluates if strings representing numbers in a given base are divisible by a given number. You might want to check an example of an automata for doing this same particular task <a href=\\\"http://math.stackexchange.com/questions/140283/why-does-this-fsm-accept-binary-numbers-divisible-by-three\\\">here</a>.”</p>\\n</blockquote>\\n<p>As a non-CS graduate, this is my first time to get in touch with a finite state machine. (It looks the state diagram in Control Theory though). Here is the link of FSM on <a href=\\\"https://en.wikipedia.org/wiki/Finite-state_machine\\\">Wikipedia</a>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/800/1*--13nyOAkb5967ngamMypQ.png\\\" alt=\\\"Image not found. Sorry for that!\\\"></p>\\n<p>In this diagram, each of the three states A, B and C represents the modulus of the input binary number, which is 0, 1 and 2 respectively. When a 0 is added to the end of a binary number, it is multiplied by 2. And when a 1 is added to the end instead, it is multiplied by 2 and then added with 1. This principle directs the flow of the bitwise calculation from one state to the other.</p>\\n<blockquote>\\n</blockquote>\\n<p>To use a regular expression to evaluate a binary string, we simply need to include all of the possible paths in the above state diagram. My solution is shown as follows.</p>\\n<blockquote>\\n</blockquote>\\n<pre><code>var multipleOf3Regex = /^(0*(1(01*0)*1)*)*$/;\\n</code></pre>\\n<p>With the same idea of this method, we are able to solve a similar kata:</p>\\n<blockquote>\\n<p>“Define a regular expression which tests if a given string representing a binary number is divisible by 5.”</p>\\n</blockquote>\\n<p>It is such a similar puzzle with the previous one. And yet there are two more states involved. It is going to be more painful going through all of the paths. But it is still achievable as long as I have enough patience. Followed the idea of the above FSM with three states, I drew out the FSM of 5 states from my understanding. (Please bear with my hand-drawing.)</p>\\n<blockquote>\\n</blockquote>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/800/1*gqeL_ITAoDoS_LhvCfuOeg.jpeg\\\" alt=\\\"Image was not found. Sorry for that!\\\"></p>\\n<blockquote>\\n</blockquote>\\n<p>The following is my regex for binary numbers divisible by 5:</p>\\n<pre><code>'^(0*(1((10)*(001*00)*)*(0|(11))(01*0(01)*(1|00))*1)*)*$'\\n</code></pre>\\n<p>And eventually, here comes the 1 kyu kata:</p>\\n<blockquote>\\n<p>“Create a function that will return a regular expression string that is capable of evaluating binary strings (which consist of only 1s and 0s) and determining whether the given string represents a number divisible by n. Inputs 1 ≤ n ≤ 18 will be tested”</p>\\n</blockquote>\\n<p>As I completed the previous two 4 kyu katas, I had a naive instinct that I should simply draw out all of the FSMs from 1 to 18, go through all of the possible paths and give out 18 regular expressions within a switch function.</p>\\n<blockquote>\\n</blockquote>\\n<p>As soon as I reached n = 6, I started to make countless amount of mistakes. It didn’t seem that I was on the right track.</p>\\n<blockquote>\\n</blockquote>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/600/1*ShzBYConxnz4IubJTjDSaw.jpeg\\\" alt=\\\"Image was not found. Sorry for that!\\\"></p>\\n<blockquote>\\n</blockquote>\\n<p>There must be a way to simplify the diagram, to eliminate the states. Fortunately, there are a plenty of tutorials accessible on the internet.</p>\\n<blockquote>\\n</blockquote>\\n<p>The state elimination method inspired me that the diagram can be simplified state by state, which is perfect for a for-loop to automize the calculation. This is what a programmer should work on, instead of trying to hard-code the problem — There is no need to mention how long the regular expression would be when the input n grows to 18.</p>\\n<blockquote>\\n</blockquote>\\n<p>After the above countlessly painful attempts, I finally had my solution for this 1 kyu problem.</p>\\n<blockquote>\\n</blockquote>\\n<pre><code>function regexDivisibleBy(n) {\\nlet Nodes = [];\\nfor(let i = 0; i &#x3C; n; i++) {\\n    Nodes.push(''+i);\\n}\\nlet paths = {},\\n    output = '';\\nfor (let i = n - 1; i >= 0; i--) {\\n    let x = Nodes[i];\\n    if(i % 2 === 0 &#x26;&#x26; i !== 0) {\\n    if(paths[Nodes[i / 2] + x]) {\\n        paths[Nodes[i / 2] + x] = `(${paths[Nodes[i / 2] + x]}|0)`;\\n    } else {\\n        paths[Nodes[i / 2] + x] = '0';\\n    }\\n    }\\n    else if (i % 2 !== 0) {\\n    if (paths[Nodes[(i - 1) / 2] + x]) {\\n        paths[Nodes[(i - 1) / 2] + x] = `(${paths[Nodes[(i - 1) / 2] + x] + x}|1)`;\\n    } else {\\n        paths[Nodes[(i - 1) / 2] + x] = '1';\\n    }\\n    }\\n    if ((2 * i) % n &#x3C; i) {\\n    if (paths[x + Nodes[(2 * i) % n]]) {\\n        paths[x + Nodes[(2 * i) % n]] = `(${paths[x + Nodes[(2 * i) % n]]}|0)`;\\n    } else {\\n        paths[x + Nodes[(2 * i) % n]] = '0';\\n    }\\n    } else if ((2 * i) % n === i) {\\n    if (paths[x + x]) {\\n        paths[x + x] = `(${paths[x + x]}0*)*`;\\n    } else {\\n        paths[x + x] = '0*';\\n    }\\n    }\\n    if ((2 * i + 1) % n &#x3C; i) {\\n    if (paths[x + Nodes[(2 * i + 1) % n]]) {\\n        paths[x + Nodes[(2 * i + 1) % n]] = `(${paths[x + Nodes[(2 * i + 1) % n]]}|1)`;\\n    } else {\\n        paths[x+Nodes[(2 * i + 1) % n]] = '1';\\n    }\\n    } else if ((2 * i + 1) % n === i) {\\n    if (paths[x + x]) {\\n        paths[x + x] = `(${paths[x + x]}1*)*`;\\n    } else {\\n        paths[x + x] = '1*';\\n    }\\n    }\\n    \\n    //eliminate states\\n    let start = [],\\n        end = [],\\n        loop = '';\\n    let pathkeys = Object.keys(paths);\\n    pathkeys.forEach(y => {\\n    if (y === x + x) {\\n        loop = paths[x + x];\\n    } else if (y[1] === x &#x26;&#x26; y[0] !== x) {\\n        start.push(y[0]);\\n    } else if (y[0] === x &#x26;&#x26; y[1] !== x) {\\n        end.push(y[1]);\\n    }\\n    });\\n    start.forEach(s => {\\n    end.forEach(e => {\\n        if (s !== e) {\\n        if (paths[s + e]) {\\n            paths[s + e] = `(${paths[s + e]}|(${paths[s + x]+loop+paths[x + e]}))`;\\n        } else {\\n            paths[s + e] = paths[s + x] + loop + paths[x + e];\\n        }\\n        } else {\\n        if (paths[s + s]) {\\n            paths[s + s] = `(${paths[s + s]}(${paths[s + x] + loop + paths[x + e]})*)`;\\n        } else {\\n            paths[s + s] = `(${paths[s + x] + loop + paths[x + e]})*`;\\n        }\\n        }\\n    });\\n    });\\n    if (i!== 0) {\\n    pathkeys.forEach(j => {\\n    if(j.indexOf(x) !== -1) {\\n        delete paths[j]\\n    }\\n    });\\n    }\\n}\\nreturn `^${paths['00']}$`;\\n}\\n</code></pre>\\n<blockquote>\\n</blockquote>\\n<p>Although it passed all of the test on Codewars, it is not an elegant solution. When I went through the solutions of other players, I noticed that the obviously better data structure to implement in this problem is diagram with linked nodes. And this gave me such a lesson that I should always firstly specify what data structure is the most suitable one before I start get my hands dirty.</p>\\n<blockquote>\\n</blockquote>\\n<p>I am working on revising my solution now. I will continue my blog about this puzzle as soon as I finish that better solution.</p>\\n<blockquote>\\n</blockquote>\\n<!-- <iframe width=\\\"560\\\" height=\\\"315\\\" src=\\\"https://www.youtube.com/embed/4n0xNbfJLR8\\\" frameborder=\\\"0\\\" allowfullscreen></iframe> -->\",\"frontmatter\":{\"title\":\"My Dive into Binary Modulus Calculation Puzzles\",\"date\":\"20 November, 2017\"}}},\"pathContext\":{\"slug\":\"/my-dive-into-binary-puzzles/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---my-dive-into-binary-puzzles-e57eca442641513f75a6.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h5>This blog summarizes my dive into a series of binary bitwise modulus calculation related Codewars puzzles.</h5>\\n<p>I’ve just become a 3 kyu player on Codewars. Recently I came across a 4 kyu kata on Codewars which caught my eyes particularly and made me decide to commit my time and effort in order to dig deeper into the problem. And finally, it led me solved my first 1 kyu kata.</p>\\n<blockquote>\\n</blockquote>\\n<p>Here is the description of that 4 kyu problem:</p>\\n<blockquote>\\n<p>“ Your task is to create a regular expression capable of evaluating binary strings (strings with only 1s and 0s) and determining whether the given string represents a number divisible by 3.”</p>\\n</blockquote>\\n<p>And it came with a hint:</p>\\n<blockquote>\\n<p>“There’s a way to develop an automata (FSM) that evaluates if strings representing numbers in a given base are divisible by a given number. You might want to check an example of an automata for doing this same particular task <a href=\\\"http://math.stackexchange.com/questions/140283/why-does-this-fsm-accept-binary-numbers-divisible-by-three\\\">here</a>.”</p>\\n</blockquote>\\n<p>As a non-CS graduate, this is my first time to get in touch with a finite state machine. (It looks the state diagram in Control Theory though). Here is the link of FSM on <a href=\\\"https://en.wikipedia.org/wiki/Finite-state_machine\\\">Wikipedia</a>.</p>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/800/1*--13nyOAkb5967ngamMypQ.png\\\" alt=\\\"Image not found. Sorry for that!\\\"></p>\\n<p>In this diagram, each of the three states A, B and C represents the modulus of the input binary number, which is 0, 1 and 2 respectively. When a 0 is added to the end of a binary number, it is multiplied by 2. And when a 1 is added to the end instead, it is multiplied by 2 and then added with 1. This principle directs the flow of the bitwise calculation from one state to the other.</p>\\n<blockquote>\\n</blockquote>\\n<p>To use a regular expression to evaluate a binary string, we simply need to include all of the possible paths in the above state diagram. My solution is shown as follows.</p>\\n<blockquote>\\n</blockquote>\\n<pre><code>var multipleOf3Regex = /^(0*(1(01*0)*1)*)*$/;\\n</code></pre>\\n<p>With the same idea of this method, we are able to solve a similar kata:</p>\\n<blockquote>\\n<p>“Define a regular expression which tests if a given string representing a binary number is divisible by 5.”</p>\\n</blockquote>\\n<p>It is such a similar puzzle with the previous one. And yet there are two more states involved. It is going to be more painful going through all of the paths. But it is still achievable as long as I have enough patience. Followed the idea of the above FSM with three states, I drew out the FSM of 5 states from my understanding. (Please bear with my hand-drawing.)</p>\\n<blockquote>\\n</blockquote>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/800/1*gqeL_ITAoDoS_LhvCfuOeg.jpeg\\\" alt=\\\"Image was not found. Sorry for that!\\\"></p>\\n<blockquote>\\n</blockquote>\\n<p>The following is my regex for binary numbers divisible by 5:</p>\\n<pre><code>'^(0*(1((10)*(001*00)*)*(0|(11))(01*0(01)*(1|00))*1)*)*$'\\n</code></pre>\\n<p>And eventually, here comes the 1 kyu kata:</p>\\n<blockquote>\\n<p>“Create a function that will return a regular expression string that is capable of evaluating binary strings (which consist of only 1s and 0s) and determining whether the given string represents a number divisible by n. Inputs 1 ≤ n ≤ 18 will be tested”</p>\\n</blockquote>\\n<p>As I completed the previous two 4 kyu katas, I had a naive instinct that I should simply draw out all of the FSMs from 1 to 18, go through all of the possible paths and give out 18 regular expressions within a switch function.</p>\\n<blockquote>\\n</blockquote>\\n<p>As soon as I reached n = 6, I started to make countless amount of mistakes. It didn’t seem that I was on the right track.</p>\\n<blockquote>\\n</blockquote>\\n<p><img src=\\\"https://cdn-images-1.medium.com/max/600/1*ShzBYConxnz4IubJTjDSaw.jpeg\\\" alt=\\\"Image was not found. Sorry for that!\\\"></p>\\n<blockquote>\\n</blockquote>\\n<p>There must be a way to simplify the diagram, to eliminate the states. Fortunately, there are a plenty of tutorials accessible on the internet.</p>\\n<blockquote>\\n</blockquote>\\n<p>The state elimination method inspired me that the diagram can be simplified state by state, which is perfect for a for-loop to automize the calculation. This is what a programmer should work on, instead of trying to hard-code the problem — There is no need to mention how long the regular expression would be when the input n grows to 18.</p>\\n<blockquote>\\n</blockquote>\\n<p>After the above countlessly painful attempts, I finally had my solution for this 1 kyu problem.</p>\\n<blockquote>\\n</blockquote>\\n<pre><code>function regexDivisibleBy(n) {\\nlet Nodes = [];\\nfor(let i = 0; i &#x3C; n; i++) {\\n    Nodes.push(''+i);\\n}\\nlet paths = {},\\n    output = '';\\nfor (let i = n - 1; i >= 0; i--) {\\n    let x = Nodes[i];\\n    if(i % 2 === 0 &#x26;&#x26; i !== 0) {\\n    if(paths[Nodes[i / 2] + x]) {\\n        paths[Nodes[i / 2] + x] = `(${paths[Nodes[i / 2] + x]}|0)`;\\n    } else {\\n        paths[Nodes[i / 2] + x] = '0';\\n    }\\n    }\\n    else if (i % 2 !== 0) {\\n    if (paths[Nodes[(i - 1) / 2] + x]) {\\n        paths[Nodes[(i - 1) / 2] + x] = `(${paths[Nodes[(i - 1) / 2] + x] + x}|1)`;\\n    } else {\\n        paths[Nodes[(i - 1) / 2] + x] = '1';\\n    }\\n    }\\n    if ((2 * i) % n &#x3C; i) {\\n    if (paths[x + Nodes[(2 * i) % n]]) {\\n        paths[x + Nodes[(2 * i) % n]] = `(${paths[x + Nodes[(2 * i) % n]]}|0)`;\\n    } else {\\n        paths[x + Nodes[(2 * i) % n]] = '0';\\n    }\\n    } else if ((2 * i) % n === i) {\\n    if (paths[x + x]) {\\n        paths[x + x] = `(${paths[x + x]}0*)*`;\\n    } else {\\n        paths[x + x] = '0*';\\n    }\\n    }\\n    if ((2 * i + 1) % n &#x3C; i) {\\n    if (paths[x + Nodes[(2 * i + 1) % n]]) {\\n        paths[x + Nodes[(2 * i + 1) % n]] = `(${paths[x + Nodes[(2 * i + 1) % n]]}|1)`;\\n    } else {\\n        paths[x+Nodes[(2 * i + 1) % n]] = '1';\\n    }\\n    } else if ((2 * i + 1) % n === i) {\\n    if (paths[x + x]) {\\n        paths[x + x] = `(${paths[x + x]}1*)*`;\\n    } else {\\n        paths[x + x] = '1*';\\n    }\\n    }\\n    \\n    //eliminate states\\n    let start = [],\\n        end = [],\\n        loop = '';\\n    let pathkeys = Object.keys(paths);\\n    pathkeys.forEach(y => {\\n    if (y === x + x) {\\n        loop = paths[x + x];\\n    } else if (y[1] === x &#x26;&#x26; y[0] !== x) {\\n        start.push(y[0]);\\n    } else if (y[0] === x &#x26;&#x26; y[1] !== x) {\\n        end.push(y[1]);\\n    }\\n    });\\n    start.forEach(s => {\\n    end.forEach(e => {\\n        if (s !== e) {\\n        if (paths[s + e]) {\\n            paths[s + e] = `(${paths[s + e]}|(${paths[s + x]+loop+paths[x + e]}))`;\\n        } else {\\n            paths[s + e] = paths[s + x] + loop + paths[x + e];\\n        }\\n        } else {\\n        if (paths[s + s]) {\\n            paths[s + s] = `(${paths[s + s]}(${paths[s + x] + loop + paths[x + e]})*)`;\\n        } else {\\n            paths[s + s] = `(${paths[s + x] + loop + paths[x + e]})*`;\\n        }\\n        }\\n    });\\n    });\\n    if (i!== 0) {\\n    pathkeys.forEach(j => {\\n    if(j.indexOf(x) !== -1) {\\n        delete paths[j]\\n    }\\n    });\\n    }\\n}\\nreturn `^${paths['00']}$`;\\n}\\n</code></pre>\\n<blockquote>\\n</blockquote>\\n<p>Although it passed all of the test on Codewars, it is not an elegant solution. When I went through the solutions of other players, I noticed that the obviously better data structure to implement in this problem is diagram with linked nodes. And this gave me such a lesson that I should always firstly specify what data structure is the most suitable one before I start get my hands dirty.</p>\\n<blockquote>\\n</blockquote>\\n<p>I am working on revising my solution now. I will continue my blog about this puzzle as soon as I finish that better solution.</p>\\n<blockquote>\\n</blockquote>\\n<!-- <iframe width=\\\"560\\\" height=\\\"315\\\" src=\\\"https://www.youtube.com/embed/4n0xNbfJLR8\\\" frameborder=\\\"0\\\" allowfullscreen></iframe> -->\",\"frontmatter\":{\"title\":\"My Dive into Binary Modulus Calculation Puzzles\",\"date\":\"20 November, 2017\"}}},\"pathContext\":{\"slug\":\"/my-dive-into-binary-puzzles/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/my-dive-into-binary-puzzles.json\n// module id = 407\n// module chunks = 45705315560200"],"sourceRoot":""}